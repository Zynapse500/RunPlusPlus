use trap::Vector2;

#[derive(Clone)]
pub struct ConvexHull {
    points: Vec<Vector2>,
    axes: Vec<Vector2>,

    ignored_normals: Vec<Vector2>
}

impl ConvexHull {
    /// Create a new convex hull from raw points and normals
    pub fn from_raw(points: Vec<Vector2>, normals: Vec<Vector2>, ignored_normals: Option<Vec<Vector2>>) -> ConvexHull {
        ConvexHull {
            points,
            axes: normals,

            ignored_normals: if let Some(normals) = ignored_normals {normals} else {Vec::new()}
        }
    }


    /// Create a new convex hull from points in a clockwise order
    pub fn from_points(points: &[Vector2]) -> ConvexHull {
        let points: Vec<Vector2> = points.iter().map(|p|{p.clone()}).collect();
        let mut normals = Vec::new();

        for i in 0..points.len() {
            let start: Vector2 = points[i];
            let end: Vector2 = points[(i + 1) % points.len()];

            let direction = (end - start).norm();
            let normal = Vector2::from([direction.y, -direction.x]);

            let mut duplicate = false;
            for n in normals.iter() {
                if normal == *n || -normal == *n {
                    duplicate = true;
                }
            }

            if !duplicate {
                normals.push(normal);
            }
        }

        ConvexHull {
            points,
            axes: normals,

            ignored_normals: Vec::new()
        }
    }


    /// Return the points of this hull
    pub fn get_points<'a>(&'a self) -> &'a [Vector2] {
        self.points.as_slice()
    }

    /// Return the normals of this hull
    pub fn get_axes<'a>(&'a self) -> &'a [Vector2] {
        self.axes.as_slice()
    }


    /// Return the average of all points of this hull
    pub fn average(&self) -> Vector2 {
        let mut sum = Vector2::new(0.0, 0.0);
        for point in self.points.iter() {
            sum += *point;
        }

        sum / self.points.len() as f64
    }


    /// Return the normals of this hull as lines
    pub fn get_normals_as_lines(&self, length: f64) -> Vec<(Vector2, Vector2)> {
        let mut lines = Vec::new();

        for i in 0..self.points.len() {
            let start: Vector2 = self.points[i];
            let end: Vector2 = self.points[(i + 1) % self.points.len()];

            let direction = (end - start).norm();
            let normal = Vector2::from([direction.y, -direction.x]);

            if !self.ignored_normals.contains(&normal) {
                let middle = (start + end) * 0.5;
                lines.push((middle, middle + normal * length));
            }
        }

        lines
    }


    /// Add a normal to the ignored list
    pub fn ignore_normal(&mut self, normal: Vector2) {
        self.ignored_normals.push(normal);
    }


    /// Clear all normals from the ignored list
    pub fn clear_ignored_normals(&mut self) {
        self.ignored_normals.clear();
    }


    /// Translate the convex hull
    pub fn translate(&mut self, amount: Vector2) {
        for point in self.points.iter_mut() {
            *point += amount;
        }
    }
}


impl super::Bounded for ConvexHull {
    fn bounding_box(&self) -> super::AABB {
        use std::f64::INFINITY;
        let mut left = INFINITY;
        let mut right = -INFINITY;
        let mut top = INFINITY;
        let mut bottom = -INFINITY;

        for point in self.points.iter() {
            if point.x < left { left = point.x; }
            if point.x > right { right = point.x; }
            if point.y < top { top = point.y; }
            if point.y > bottom { bottom = point.y; }
        }

        super::AABB {
            left,
            right,
            top,
            bottom,
            edges: [true; 4],
        }
    }
}


impl super::Collide<ConvexHull> for ConvexHull {
    fn overlap(&self, other: &ConvexHull) -> Option<(f64, Vector2)> {
        let axes = self.axes.iter().chain(other.axes.iter());

        let mut min_overlap = None;
        let mut min_axis = None;

        for axis in axes {
            let (self_min, self_max) = super::projected_range(self.points.as_slice(), *axis);
            let (other_min, other_max) = super::projected_range(other.points.as_slice(), *axis);

            if self_min < other_max && other_min < self_max {
                let left = self_max - other_min;
                let right = other_max - self_min;

                let (overlap, normal) = if left < right {(left, -*axis)} else {(right, *axis)};

                // Ignore any overlap generated by ignored normals
                if self.ignored_normals.contains(&(-normal)) ||
                    other.ignored_normals.contains(&normal) {
                    continue;
                }

                if min_overlap.is_none() {
                    min_overlap = Some(overlap);
                    min_axis = Some(normal);
                } else {
                    if overlap < min_overlap.unwrap() {
                        min_overlap = Some(overlap);
                        min_axis = Some(normal);
                    }
                }
            } else {
                return None;
            }
        }

        if min_overlap.is_some() && min_axis.is_some() {
            let overlap = min_overlap.unwrap();
            return Some((overlap, overlap * min_axis.unwrap()));
        } else {
            None
        }
    }
}


impl super::Collide<super::Circle> for ConvexHull {
    fn overlap(&self, circle: &super::Circle) -> Option<(f64, Vector2)> {
        // Axes to test: [convex normals, direction from circle to closest point]
        use std::f64::INFINITY;
        let mut closest = 0;
        let mut smallest_distance = INFINITY;

        for (i, point) in self.points.iter().enumerate() {
            let distance = point.distance(circle.center);
            if distance < smallest_distance {
                smallest_distance = distance;
                closest = i;
            }
        }


        let mut inside = false;
        for i in 0..self.points.len() {
            let a = self.points[i];
            let b = self.points[(i + 1) % self.points.len()];

            let direction = (b - a).norm();
            let a_dot = direction.dot(a);
            let b_dot = direction.dot(b);

            let c_dot = direction.dot(circle.center);
            if a_dot < c_dot && c_dot < b_dot {
                inside = true;
            }
        }


        if smallest_distance < circle.radius && !inside {
            let direction = (self.points[closest] - circle.center).norm();
            if !self.ignored_normals.iter().any(|n|{ let dot = direction.dot(*n); -0.99 > dot || dot > 0.99}) {
                let overlap = circle.radius - smallest_distance;
                return Some((overlap, overlap * direction));
            }
        }


        if inside {
            let axes = self.axes.iter();
            let mut min_overlap = None;
            let mut min_axis = None;


            for axis in axes {
                let (self_min, self_max) = super::projected_range(self.points.as_slice(), *axis);
                let (other_min, other_max) = super::projected_range(&[
                    circle.center + circle.radius * *axis,
                    circle.center - circle.radius * *axis
                ], *axis);

                if self_min < other_max && other_min < self_max {
                    let left = self_max - other_min;
                    let right = other_max - self_min;

                    let (overlap, normal) = if left < right {(left, -*axis)} else {(right, *axis)};

                    // Ignore any overlap generated by ignored normals
                    if self.ignored_normals.contains(&(-normal)) {
                        continue;
                    }

                    if min_overlap.is_none() {
                        min_overlap = Some(overlap);
                        min_axis = Some(normal);
                    } else {
                        if overlap < min_overlap.unwrap() {
                            min_overlap = Some(overlap);
                            min_axis = Some(normal);
                        }
                    }
                } else {
                    return None;
                }
            }

            if min_overlap.is_some() && min_axis.is_some() {
                let overlap = min_overlap.unwrap();
                return Some((overlap, overlap * min_axis.unwrap()));
            }
        }

        None
    }
}